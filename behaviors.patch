diff --git a/ns_sim_2_0/sim/behaviors_ns.py b/ns_sim_2_0/sim/behaviors_ns.py
index 3333333..4444444 100644
--- a/ns_sim_2_0/sim/behaviors_ns.py
+++ b/ns_sim_2_0/sim/behaviors_ns.py
@@
-from __future__ import annotations
-from typing import List, Tuple
-import math
-
-from evo_sim.sim.config import WORLD, TRAITS, BEHAV
-
-Vec = Tuple[float, float]
-EAT_RATIO = 1.2
+from __future__ import annotations
+from typing import List, Tuple
+import math
+
+from evo_sim.sim.config import WORLD, TRAITS, BEHAV
+
+Vec = Tuple[float, float]
@@
-def bite_radius(size: float) -> float:
+def bite_radius(size: float) -> float:
     return WORLD.bite_radius_scale * size
+
+def _nearest_edge_target(x: float, y: float) -> Tuple[float, float, float]:
+    """
+    Return (tx, ty, dist) where (tx,ty) is the closest point on any world edge to (x,y),
+    and dist is the Euclidean distance to that point.
+    """
+    W, H = WORLD.width, WORLD.height
+    # Four edge projections
+    candidates = [
+        (0.0, y),       # left
+        (W,   y),       # right
+        (x,   0.0),     # bottom
+        (x,   H),       # top
+    ]
+    best = None
+    best_d2 = float("inf")
+    for tx, ty in candidates:
+        d2 = (tx - x)**2 + (ty - y)**2
+        if d2 < best_d2:
+            best_d2 = d2
+            best = (tx, ty)
+    tx, ty = best
+    return tx, ty, math.sqrt(best_d2)
@@
 def step_behavior(world, me, others: List, dt: float, steps_left: int) -> Vec:
     if not me.alive:
         return (0.0, 0.0)
@@
-    # Flee the nearest larger creature (>= 1.2x size)
-    predator = None
-    best_d2 = r_pred * r_pred
-    for o in others:
-        if not o.alive or o.id == me.id:
-            continue
-        if o.size >= EAT_RATIO * me.size:
-            d2 = (o.x - me.x)**2 + (o.y - me.y)**2
-            if d2 <= best_d2:
-                predator = o; best_d2 = d2
-    if predator is not None:
-        away = (me.x - predator.x, me.y - predator.y)
-        return _mul(_unit(away), eff)
+    # NS rule: no predation â†’ no flee from other creatures
@@
-    # Return home when flagged by LiveSim (time/energy/food logic handled there)
-    if me.going_home:
-        to_home = (me.home[0] - me.x, me.home[1] - me.y)
-        return _mul(_unit(to_home), eff)
+    # --- Return-to-edge logic ---
+    # Always go home after 2 foods
+    if me.eaten >= 2:
+        me.going_home = True
+    # After 1 food: if time is tight to reach the nearest edge, go home
+    if me.eaten == 1:
+        tx, ty, dist = _nearest_edge_target(me.x, me.y)
+        time_need = dist / max(eff, 1e-6)
+        time_have = steps_left * dt
+        if time_need >= 0.92 * time_have:   # conservative safety factor
+            me.going_home = True
+    # If we're going home, steer to the nearest edge point
+    if me.going_home:
+        tx, ty, _ = _nearest_edge_target(me.x, me.y)
+        to_edge = (tx - me.x, ty - me.y)
+        return _mul(_unit(to_edge), eff)
@@
     # Seek nearest food if within sense
     f = world.nearest_food_within(me.x, me.y, r_food)
     if f is not None:
         to_food = (f.x - me.x, f.y - me.y)
         return _mul(_unit(to_food), eff)
@@
-    drift = (BEHAV.wander_turn_rate * dt)
-    me.heading += drift * (0.5 - (hash((me.id, me.x, me.y)) & 1))
+    drift = (BEHAV.wander_turn_rate * dt)
+    me.heading += drift * (0.5 - (hash((me.id, me.x, me.y)) & 1))
     vmag = BEHAV.wander_speed_fraction * eff
     return (math.cos(me.heading) * vmag, math.sin(me.heading) * vmag)